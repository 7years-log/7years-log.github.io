<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言错题集</title>
      <link href="2021/06/01/C%E8%AF%AD%E8%A8%80%E9%94%99%E9%A2%98%E9%9B%86/"/>
      <url>2021/06/01/C%E8%AF%AD%E8%A8%80%E9%94%99%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>在VC中，若定义一个函数的返回类型为void，则以下叙述正确的是（  ）。函数本身没有返回值</p><p>代码int i=3；i&lt;&lt;=4;i的值等于多少？（）110000（二进制）<br>i&lt;&lt;4 = 3 * 2^4 = 48 = 11000</p><p>&lt;&lt;是左移运算符的意思，左移运算符是用来将一个数的各二进制位全部左移若干位。</p><p>这里可以理解为把3化为2进制，然后统一左移4位。<br>3的二进制比如    0011    左移4位   110000 = 48</p><p>C代码中可能会出现如下类型的结构体定义：<br>typedef struct holder {<br>struct holder *next;<br>struct holder *prev;<br>char buffer[ 0 ];<br>}holder;<br>最后一行 char data[ 0 ] 作用是？</p><p>方便管理内存缓冲区<br>减少内存碎片化</p><p>#include “stdio.h”<br>main（）<br>{<br>int a=8,b;<br>b=a|1;<br>b&gt;&gt;=1;<br>printf（”%d,%d＼n”,a,b）;<br>}<br>上面的C程序段的输出为（   ）：<br>C语言中|是按位或的意思，a可以表示为00001000,1表示为00000001，因此b为00001001,＞＞表示右移一位，因此b为00000100，即为4</p><p>C语言中左移和右移运算符的用法：左移运算符就是把最高位丢弃掉然后在最低位补0；右移运算法与左移是相反的，它是往右边挪动若干位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux错题集</title>
      <link href="2021/06/01/Linux%E9%94%99%E9%A2%98%E9%9B%86/"/>
      <url>2021/06/01/Linux%E9%94%99%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>ps（Process Status）：查看系统进程的情况<br>nestat：查看网络情况<br>df（disk free）：查看磁盘情况<br>ifconfig：用来查看和配置网络设备，当网络环境发生改变时可通过此命令对网络进行相应的配置 </p><p>export：用于将shell变量输出为环境变量，或者将shell：函数输出为环境变量<br>cat：经常用来显示文件的内容<br>echo：用于在shell中打印shell变量的值，或者直接输出指定的字符串<br>env：用于显示系统中已存在的环境变量，以及在定义的环境中执行指令</p><p>linux命令执行成功后返回和C语言里的main函数一样，正确返回0,其他的数字代表各种各样的错误</p><p>假设我有test1.c,test2.c两个源文件，先使用gcc -c *.c将源文件编译成目标文件，可以生成了test1.o,test2.o两个目标文件，然后，使用ar命令：ar crv libtest.a *.o将该目录下的所有目标文件打包生成了libtest.a文件。这样，你在编译的时候就可以直接使用这个静态库了。</p><p>vsftpd服务流量控制的参数：<br>访问速率设置：<br>anon_max_rate=0<br>设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。<br>local_max_rate=0<br>本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0。</p><p>(1)    PWD 和 OLDPWD</p><pre><code>   PWD 记录当前的目录路径，当利用 cd 命令切换当前目录时，系统自动更新 PWD 的值， OLDPWD 记录旧的工作目录，即用户所处的前一个目录。</code></pre><p>(2)    PATH</p><pre><code>   PATH 是 Linux 中一个极为重要的环境变量，它用于帮助 Shell 找到用户输入的命令。用户所输入的每个命令实际上是一个源代码文件，计算机执行这个文件里的代码以实现这个命令的功能，这些源代码文件称为可执行文件。可执行文件存在于各种各样的目录下， PATH 就记录了一系列的目录列表， Shell 为每个输入命令搜索 PATH 中的目录列表。</code></pre><p>(3)    HOME</p><pre><code>   HOME 记录当前用户的目录，由 /etc/passwd 的倒数第 2 个域决定， HOME 目录用于保存用户自己的文件。</code></pre><p>mkswap</p><p>功能说明：设置交换区(swap area)，可将磁盘分区或文件设为Linux的交换区</p><p>swapon</p><p>功能说明：启动交换文件</p><p>swapoff<br>功能说明：关闭系统交换分区</p><p>将文件xyz中的单词AAA全部替换为BBB：sed ‘s/AAA/BBB/g’ xyz</p><p>怎样将字符AAA全部替换成yyy? s/AAA/yyy/g</p><p>为了查看不断更新的日志文件，可以使用的指令是:tail -f</p><p>下列哪个命令可以看到文件的大小？（不添加参数的情况下）:du</p><p>ls是list的缩写，用来显示当前目录下面文件的信息；</p><p>df是disk free的缩写，用来显示文件系统中不同磁盘的使用情况；</p><p>du是disk usage的缩写，显示当前目录或者当前文件的占用的块大小；</p><p>find命令作用在目录下，用来查找指定目录或者当前目录下的文件。</p><p>find 查找<br>. 在当前目录查找<br>-name 指定文件名<br>-mtime 指定修改时间(以天为单位) +xx 修改时间大于xx天 -xx修改时间小于xx天<br>-type 不知什么意思 应该是指定文件类型<br>-size 指定文件大小 +xx文件大小大于xx -xx文件大小小于xx<br>xargs 把前一命令输入当作后一命令输出，通常配合管道使用</p><p>查找当前目录一个月(30天)以前大于100M的日志文件(.log)并删除：find  . -name “*.log” –mtime +30 –type f –size +100M |xargs rm –rf {} ;</p><p>Linux什么情况下回发生page fault：所需访问虚拟内存未被装载</p><p>创建用户时不指定用户主目录的参数：useradd -M</p><p>POSIX线程中如果数据被其他线程修改，则应把数据声明为：volatile</p><p>volatile是一个类型修饰符（type specifier）作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。<br>volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。<br>根据题意，数据可以被其他线程修改，而要不出错的达到这样的要求，就可以使用volatile修饰这个变量。</p><p>POSIX信号量函数的名字都以（      ）开头。：sem_</p><p>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>哪些命令可以查看当前系统的启动时间：w  top uptime</p><p>ps   查看当前系统中的进程<br>who -b   查看当前系统的启动时间<br>last reboot   查看当前系统的启动时间<br>w    查看当前系统的启动时间<br>top   查看当前系统的启动时间<br>uptime    查看当前系统的启动时间</p><p>Linux 下进程间的通信方式有以下几种<br>（1）管道/无名管道<br>（2）信号<br>（3）共享内存<br>（4）消息队列<br>（5）信号量<br>（6）socket<br>这是书上说的六种通信方式，通过文件锁的方式也可以实现进程间的通信（上网查了一下）所以要记住文件锁</p><p>inux防火墙iptabls拒绝所有客户端ping数据包的规则是：iptables -A INPUT -s ! 127.0.0.1 -p icmp -j DROP   </p><p>iptables -A INPUT -s 0.0.0.0 -p icmp -j DROP</p><p>网络管理员在/opt分区上安装应用软件，提示磁盘可用空间不足,解决需要的指令和参数是：umount /opt、resize、parted</p><p>局域网的网络地址192.168.1.0/24，局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0/24网络时，其路由设置正确的是？：route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</p><p>-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络</p><p>cut ：从文本文件的每一行中截取指定内容的数据。</p><p>cp ：用来复制文件或目录。</p><p>dd ：将指定的输入文件拷贝到输出文件中，在拷贝的过程中可以进行格式转换。</p><p>fmt ：将所有非空白行的长度设置为几乎相同，来进行简单的文本格式化。</p><p>文件exer1的访问权限为rw-r–r–,现要增加所有用户的执行权限和同组用户的写权限：文字设定法<br>chmod ［who］ ［+ | - | =］ ［mode］ 文件名¼</p><pre><code>  u 表示“用户（user）”，即文件或目录的所有者。</code></pre><p>g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。<br>o 表示“其他（others）用户”。<br>a 表示“所有（all）用户”。它是系统默认值。<br>操作符号可以是：</p><ul><li>添加某个权限。</li></ul><ul><li><p>取消某个权限。<br>   = 赋予给定权限并取消其他所有权限（如果有的话）。<br> 数字设定法的一般形式为：<br>chmod ［mode］ 文件名¼</p><pre><code>我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以       数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。</code></pre></li></ul><p>例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。</p><p>内核不包括的子系统是 ：硬件管理系统</p><p>具有很多C语言的功能，又称过滤器的是？：awk</p><p>sed awk grep ,linux文本处理三剑客</p><p>csh:调用 C shell。<br>Tcsh是csh的增强版，并且完全兼容csh。它不但具有csh的全部功能，还具有命令行编辑、拼写校正、可编程字符集、历史纪录、 作业控制 等功能，以及C语言风格的语法结构。<br>AWK 是一种优良的文本处理工具， Linux 及 Unix 环境中现有的功能最强大的数据处理引擎之一, AWK 提供了极其强大的功能：可以进行样式装入、 流控制 、数学 运算符 、进程 控制语句 甚至于内置的变量和函数。<br>SED: Stream EDitor</p><p>Linux crontab中* * * * * /usr/local/run.sh这句话5个*号分别代表什么？分钟 小时 日 月 星期</p><p>linux下查看磁盘挂载状态的命令式？：mount</p><p>安装命令：rpm -ivh<br>卸载命令: rpm -e [package name]<br>查看挂载状态: mount<br>查看磁盘情况: df<br>查看端口:netstat –anlp<br>tar.gz的安装:<br>tar –zxvf tar.gz<br>./configure<br>Make<br>Make install</p><p>u-g-o：所有用户-组内用户-其他用户<br>r-w-x：用4-2-1表示。<br>组外成员o的权限为只读：r– = 4<br>所有者a有全部权限：rwx; = 7<br>组内g的权限为读与写:rw- = 6</p><ul><li>物理层： RJ45 、 CLOCK 、 IEEE802.3 （中继器，集线器，网关） -<br>数据链路： PPP 、 FR 、 HDLC 、 VLAN 、 MAC （网桥，交换机） -<br>网络层： IP 、 ICMP 、 ARP 、 RARP 、 OSPF 、 IPX 、 RIP 、 IGRP 、 （路由器） -<br>传输层： TCP 、 UDP 、 SPX -<br>会话层： NFS 、 SQL 、 NETBIOS 、 RPC -<br>表示层： JPEG 、 MPEG 、 ASII -<br>应用层： FTP 、 DNS 、 Telnet 、 SMTP 、 HTTP 、 WWW 、 NFS</li></ul><p>www 80 ，ftp  20 ，21，书上一般写ftp端口21，对应两种模式，应该是主动20，被动模式20</p><p>一般情况下，串行程序并行化设计需要将工作进行拆分，使得分布在每个进程中的工作量大致相仿，并行让它们之间的通信量最少。以下串行程序并行化设计步骤正确的是： 1、将串行程序中需要要执行的指令和数据按照计算部分拆分成多个小任务 2、将上一步聚合好的任务分配到进程/线程中。这一步还主要注意的是，要使得通信量最小化，让各个进程/线程所得到的工作量大致均衡 3、确定第一步识别出来的任务之间需要执行何种通信 4、将第一步确定的任务与通信结合成更大的任务:1-&gt;3-&gt;4-&gt;2</p><p>ping命令：用来测试主机之间网络的连通性</p><p>nestat命令：用来打印Linux中网络系统的状态信息，可以让你得知整个Linux系统的网络情况</p><p> char * strtok(char *str, const char *ch) 将字符串S按照字符ch分解</p><p>使用git merge命令；<br>使用git pull命令；<br>使用git cherry-pick命令<br>都可以合并代码<br>执行git blame;命令时,会逐行显示文件,并在每一行的行首显示commit号,提交者,最早的提交日期等</p><p>在Linux 系统中，在运行一个程序时，程序中未初始化的全局变量会被加载到以下哪个内存段中?：BSS</p><p>BSS（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域。特点是:可读写的，在程序执行之前BSS段会自动清0。所以，未初始的全局变量在程序执行之前已经成0了。</p><p>数据段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</p><p>代码段：代码段（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</p><p>堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</p><p>栈(stack)：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区</p><p>malloc是glibc里的库函数，它封装了一些向系统申请内存的系统调用，而且并不是每次使用malloc的时候都会向系统申请新的内存，所以D是错的</p><p>malloc是库函数，”操作系统申请内存的接口 “指的是系统调用，库函数中封装了系统调用，库函数与系统调用是两个不同的概念</p><p>对于Linux说法，下列说法正确的是：线性访问内存非法时，当前线程会进入信号处理函数</p><p>ulimit用于shell启动进程所占用的资源</p><p>用mv命令移动文件时，文件的修改时间不会发生变化</p><p>如何在命令行查看一台linux机器的CPU、SWAP分区信息、硬盘信息?cat /proc/cpuinfo。cat /proc/swaps。df -lh</p><p>cat /proc/cpuinfo：查看一台linux机器的CPU信息 du：查看该目录占用文件系统数据块的情况<br>cat /proc/swaps：查看SWAP分区信息<br>df -lh：查看硬盘信息</p><p>在linux编程中，以下哪个TCP的套接字选项与算法的开启和关闭有关？：TCP_NODELAY</p><p>linux 2.6.* 内核默认支持的文件系统有哪些？ext3、ext2、ext4、xfs</p><p>Samba 服务器的配置文件是：smb.conf</p><p>WEB服务器配置文件  http.conf<br>启动脚本配置文件   initd.conf<br>samba脚本          rc.samba<br>samba服务配置文件  smb.conf</p><p>Linux文件权限一共10位长度，分成四段，第三段表示的内容是：文件所有者所在组的权限<br>1，代表文件类型，一般有三类，- 代表普通的二进制文件，l 代表符号链接文件（软链接），d 代表目录文件<br>2-4，代表文件所有者的权限表示情况，分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限<br>5-7，代表文件所有这所属组的权限表示情况。分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限<br>8-10,代表除文件所有者和所属组的其他人所拥有的权限表示情况。分别对应 可读(r) 可写(w) 可执行(w)，- 代表没有该项权限<br>如；umask 的值为022</p><p>创建一个文件的默认权限应该就是777-022=755<br>由于 执行权限(x) 比较危险，Linux默认不会赋予此权限，所以实际创建文件的默认权限是 755-111=644<br>如果此时创建的是一个软链接文件，则权限位为 lrx-r–r-；如果此时创建的是一个普通文件，则权限位为 -rx-r–r–；如果此时创建的是一个目录文件，则权限位为 drx-r–r–</p><p>chown 将指定文件的拥有者改为指定的用户或组</p><p>缺省的Linux系统中，从后台启动进程，应在命令的结尾加上哪个符号？&amp;</p><p>后台运行可以有两种方式： 1.命令前加nohup # nohup  *.sh 2.命令后加&amp; #  *.sh &amp;</p><p>Linux的可执行文件开头的特征字符串是什么？ELF</p><p>哪个变量用来指定一个远程X应用程序将输出放到哪个X server上：DISPLAY</p><p>修改/etc/sysctl.conf如下哪项参数可以开启Linux流量转发功能（）：net.ipv4.ip_forward = 1</p><p>若基于Linux操作系统所开发的ARM应用程序源文件名为test.c，那么要生成该程序代码的调试信息，编译时使用的GCC命令正确的是?：arm-linux-gcc -g -o test test.c</p><p>Linux执行ls，会引起哪些系统调用（）：read、execve、fork</p><p>任何shell都会执行 exec 和 fork<br>而    ls会执行read<br>三个加起来</p><p>以下哪些命令可以获取linux主机的负载相关指标：uptime、top、sar</p><p>uptime命令过去只显示系统运行多久。现在，可以显示系统已经运行了多长时间，信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。<br>top命令可以查看系统整体状态<br>最后一些输出信息的解释：<br>load average: 0.09, 0.05, 0.01<br>三个数分别代表不同时间段的系统平均负载(一分钟、五 分钟、以及十五分钟)，它们的数字是越小越好。在多核处理中，系统的均值不应该高于处理器核心的总数量<br>进程使用的内存可以用top,有3个列VIRT RES SHR, 标示了进程使用的内存情况, VIRT标识这个进程可以使用的内存总大小, 包括这个进程真实使用的内存, 映射过的文件, 和别的进程共享的内存等. RES标识这个这个进程真实占用内存的大小. SHR标识可以和别的进程共享的内存和库大小.<br>sar -u输出显示CPU信息。-u选项是sar的默认选项。该输出以百分比显示CPU的使用情况<br>ls跟dos下的dir命令是一样的都是用来列出目录下的文件<br>crontab是一个定时执行任务命令，不能查看系统负载。</p><p>★/bin 可执行文件（二进制）</p><p>★/boot linux内核和系统启动文件</p><p>★/dev 设备文件</p><p>★/etc 系统配置文件</p><p>★/home 用户主目录</p><p>★/initrd 启动时挂在initrdimg映像文件</p><p>★/lib 共享库文件</p><p>★/lost+found fsck放置的零散文件</p><p>★/media 系统自动挂在CD-ROM</p><p>★/mnt 被挂载的文件系统</p><p>★/opt 可选文件和程序的存放目录</p><p>★/proc 存放所有标志为文件的进程</p><p>★/root 根用户的主目录</p><p>★/sbin 存放更多的可执行文件（二进制）</p><p>★/srv</p><p>★/sys</p><p>★/tmp 存放用户和程序的临时文件</p><p> int pthread_mutex_destroy(pthread_mutex_t *mutex); //销毁互斥锁<br> int pthread_mutex_lock(pthread_mutex_t *mutex);  //以原子操作方式给互斥锁加锁<br> int pthread_mutex_trylock(pthread_mutex_t *mutex); //非阻塞版本<br> int pthread_mutex_unlock(pthread_mutex_t *mutex); // 以原子操作方式给互斥锁解锁</p><p> pthread_mutex_init 初始化一个互斥量<br>pthread_mutex_lock 给一个互斥量加锁<br>pthread_mutex_trylock 加锁，如果失败不阻塞<br>pthread_mutex_unlock 解锁<br>pthread_mutex_destroy 销毁互斥锁</p><p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。<br>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;<br>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;<br>/dev/zero：是一个输入设备，你可你用它来初始化文件。<br>/mnt/sw1：Linux操作系统下的挂载目录下的交换分区目录<br>swapon：开启交换分区<br>mkswap：设置交换分区<br>mkfs：建立 linux 文件系统在特定的分区上</p><p>某公司网络中心升级web服务器的物理内存,相应的要提高linux服务器交换空间,以下可以扩展交换空间的操作是（      ）:dd if=/dev/zero of=/mnt/sw1;swapon /mnt/sw1</p><p>vivek希望将他的login ID从vivek改为viv，应该执行下列哪个命令？:usermod -l viv vivek</p><p>usermod(选项)(参数)：参数若为两个，顺序一般为  usermod (选项)  目标参数  原始参数<br>-c&lt;备注&gt;：修改用户帐号的备注文字；<br>-d&lt;登入目录&gt;：修改用户登入时的目录；<br>-e&lt;有效期限&gt;：修改帐号的有效期限；<br>-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号；<br>-g&lt;群组&gt;：修改用户所属的群组；<br>-G&lt;群组&gt;；修改用户所属的附加群组；<br>-l&lt;帐号名称&gt;：修改用户帐号名称；<br>-L：锁定用户密码，使密码无效；<br>-s：修改用户登入后所使用的shell；<br>-u：修改用户ID；<br>-U:解除密码锁定。</p><p>在Redhat公司发布的Linux版本中，若要使得用户登录验证，需要修改以下__ _ ___脚本。/etc/shadow</p><p>/ect/passwd用来保存用户的基本信息，而/etc/shadow用来保存所有用户的密码，在/etc/shadow中第二字段为用户的加密密码，如果密码是”!!”或” * “则代表没有密码不能登录，需要用户登录验证</p><p>Redhat9 所支持的安装方式有（）:<br>从本地硬盘驱动器进行安装<br>通过NFS进行网络安装<br>通过HTTP进行网络安装</p><p>新建一个管理员用户admin,需要使用的参数():useradd -u 0 -o admin</p><p>-u 表示指定用户的用户号，由于系统用户的用户号是0，所以指定用户号为0。如果同时有-o选项，则可以重复使用其他用户的标识号；即-u 0 -o admin的到相同的效果。但是系统本身勋在用户号为0 的系统用户，则这里应该使用-o admin参数；</p><p>写出linux命令: 在当前目录及其子目录所有的.cpp文件中查找字符串”example”, 不区分大小写？grep -i -r example ./*.cpp</p><p>grep常用参数：<br>    -e :使用正则<br>    -i：忽略大小写<br>    -v：查找不包括指定内容的行<br>    -w：按单词查找<br>    -c：统计匹配次数<br>    -n：显示行号<br>    -r：递归遍历目录查找<br>    -A：显示匹配行前面多少行<br>    -B：显示匹配行后面多少行<br>    -C：显示匹配行前后多少行<br>    -include：指定匹配的文件类型<br>    -exclude:过滤不需要匹配的文件类型<br>常用栗子：<br>多文件查询jieni：grep jieni pika.log zhongzi.log<br>查找包含jieni又包含gui的行：grep jieni pika.log | grep gui<br>查找匹配jieni或者匹配gui的行：grep jieni | gui pika.log<br>显示匹配jieni行的前2行： grep jieni pika.log -A2<br>显示匹配行的后2行： grep jieni pika.log -B2<br>显示匹配行的前后两行：grep jieni pika.log -C2<br>不区分大小写： grep -i jieni pika.log<br>使用正则： grep -e ‘[a-z]’ pika.log<br>查找不含jieni的行： grep -v jieni pika.log<br>统计jieni的行数：grep -c jieni pika.log<br>遍历当前目录和所有子目录匹配：grep -r jieni .<br>在当前目录和子目录中查找所有pika文件中查找jieni: grep -r jieni . –include “*.pika”<br>查找并输出到指定文件： grep jieni pika.log &gt; result.log<br>查找jieni开头的行：grep ^jieni pika.log<br>结尾的行：grep jieni$ pika.log<br>查找空行： grep ^$ pika.log</p><p>以下哪个命令可实现文件：sort demo.txt|uniq</p><p>uniq 命令删除文件中的重复行</p><p>建立动态路由需要用到的文件有（）/etc/gateways</p><p>/etc/hosts 设定用户自已的IP与名字的对应表</p><p>/etc/gateways 设定路由器<br>/etc/resolv.conf    设置DNS </p><p>每天开机在/misc目录下创建一个当天日期的文件夹（      ）echo “mkdir /misc/<code>date +%Y%m%d</code>“&gt;&gt;/etc/rc.d/rc.local</p><p>查看后台进程作业ID的指令是（ ）jobs</p><p>ps命令用来列出系统中当前运行的那些进程<br>ls显示当前目录中的文件名字<br>pg提供了一次性的查看进程结果,但所提供的查看结果不是动态连续的<br>jobs 查看后台进程作业</p><p>在重新启动Linux系统的同时把内存中的信息写入硬盘，应使用（）命令实现#shutdown -r now</p><p>shutdown：  这个命令会通知系统内的各个进程，并通知关闭一些服务。<br>shutdown -h now 立刻关机                      常用<br>shutdown -h 20:25 指定关机的时间<br>shutdown -h +10  10分钟后关机<br>shutdown -r now 系统立刻重启<br>shutdown -r +30 ‘the system will reboot’  显示题是信息给所有在线用户<br>shutdown -k now ‘system will reboot’  仅仅发出要重新启动的信息，而不会关机或者重启</p><hr><p>reboot ： 删除所有进程，不平稳终止。<br> ‘sync；sync；sync；reboot’  </p><hr><h2 id="halt：-不理会目前系统状态，执行硬件关机。"><a href="#halt：-不理会目前系统状态，执行硬件关机。" class="headerlink" title="halt： 不理会目前系统状态，执行硬件关机。"></a>halt： 不理会目前系统状态，执行硬件关机。</h2><p>init： 用于切换系统的运行级别，切换的工作是立即完成的。<br>init 0 关机<br>init 3 命令行模式<br>Init5 含有图形界面<br>init 4重启</p><p>有一个文件ip.txt，每行一条ip记录，共若干行，已排好序，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？（ ）uniq -c ip.txt | sort -nr | head -n 3</p><p>在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件？ /etc/skel</p><p>在linux编程中，以下哪个TCP的套接字选项与nagle算法的开启和关闭有关？TCP_NODELAY</p><p>linux防火墙iptabls拒绝所有客户端ping数据包的规则是(      )。iptables -A INPUT -s 0.0.0.0 -p icmp -j DROP<br>iptables -A INPUT -s ! 127.0.0.1 -p icmp -j DROP</p><p>top查看CPU、netstat显示网络连接、路由表、网络接口信息、free查看内存使用情况、df检查文件系统的磁盘空间的占用情况</p><p>用ls –al 命令列出下面的文件列表，哪个文件是符号连接文件？lrwxr–r– 1 hel users 2024 Sep 12 08:12 cheng &gt; peng.yan1</p><p>当内网内没有条件建立dns服务器，又不想用IP访问网站，应配置什么文件:</p><p>公司网络中心linux服务器需要升级OA系统,为了防止客户登录影响系统升级,网络管理员可以执行的操作有（      ）touch /etc/nolgoin、init 3、iptable -S INPUT -t tcp -s !127.0.0.1 -j DROP<br>touch /etc/nolgoin： 禁止所有普通用户登录</p><p>编译内核时，可以使用哪些命令对内核进行配置？make config、make menuconfig、make xconfig、make oldconfig</p><p>make config - 纯文本界面 (最常用的选择)。<br>make menuconfig - 基于文本彩色菜单和单选列表。这个选项可以加快开发者开发速度。需要安装ncurses(ncurses-devel)。<br>make nconfig - 基于文本的彩色菜单。需要安装curses (libcdk5-dev)。<br>make xconfig - QT/X-windows 界面。需要安装QT。<br>make gconfig - Gtk/X-windows 界面。需要安装GTK。<br>make oldconfig - 纯文本界面，但是其默认的问题是基于已有的本地配置文件。<br>make silentoldconfig - 和oldconfig相似，但是不会显示配置文件中已有的问题的回答。<br>make olddefconfig -和silentoldconfig相似，但有些问题已经以它们的默认值选择。<br>make defconfig - 这个选项将会创建一份以当前系统架构为基础的默认设置文件。<br>make ${PLATFORM}defconfig - 创建一份使用arch/$ARCH/configs/${PLATFORM}defconfig中的值的配置文件。<br>make allyesconfig - 这个选项将会创建一份尽可能多的问题回答都为‘yes’的配置文件。<br>make allmodconfig - 这个选项将会创建一份将尽可能多的内核部分配置为模块的配置文件。</p><p>有两台游戏服务器运行于linux 2.6.x内核上，需要同步用户访问日志，你会用下列哪些方法同步日志（开放题：假设权限和条件均可满足）？rsync</p><p>Linux文件系统的文件都按其作用分门别类地放在相关的目录中，对于外部设备文件，一般应将其放在()目录中:/dev</p><p>建立动态路由需要用到的文件有（）/etc/gateways</p><p>tar命令用于解压的参数是？-x</p><p>网络管理员查看进程时，发现有三个挂起进程,现继续运行作业号为2的进程,下列方式正确的有（      ）</p><p>如果存在文本文件/tmp/testfile，并且文件行数小于等于10行，则输出文件前3行，下列脚本正确的是if [[ -f ‘/tmp/testfile’ ]] &amp;&amp; [[ <code>wc -l /tmp/testfile</code> -le 10 ]];then<br>    head -3 /tmp/testfile<br>fi</p><p>激活网卡就用ifconfig eth0 up</p><p>如何获取上一条命令执行的返回码$?</p><p>Linux程序运行后，文件句柄0，1，2分别是：（）标准输入，标准输出，标准错误</p><p>句柄       设备名称            逻辑设备名             缺省设备<br>00       标准输入设备        CON                       键盘<br>01        标准输出设备       con                         显示器<br>02        标准错误设备       CON                       显示器<br>03        标准辅助设备        AUX                       串行口<br>04         标准列表设备       PRN                       打印机</p><p>文件IO中读取文件首先调用系统函数并传送文件名，选择一个路径打开文件。函数取回的顺序号就是文件句柄。<br>0标准输入 1标准输出 2标准错误 3标准辅助 4标准列表</p><p>$# 是传给脚本的参数个数<br>$0是脚本本身的名字<br>$1是传递给该shell脚本的第一个参数<br>$2是传递给该shell脚本的第二个参数<br>$@ 是传给脚本的所有参数的列表<br>$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个<br>$$ 是脚本运行的当前进程ID号<br>$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</p><p>linux下解释: ip rule add from 192.168.3.112/32 [tos 0x10] table 2 pref 1500。</p><p>向规则链增加一条规则，规则匹配的对象是IP为192.168.3.112，tos等于0x10的包，使用路由表2，这条规则的优先级是1500</p><p>pref是preference（优先）的缩写</p><p>man 5 passwd显示passwd文件的结构</p><p>man的级别：<br>1：查看命令的帮助<br>2：查看可被内核调用的函数的帮助<br>3：查看函数和函数库的帮助<br>4：查看特殊文件的帮助（主要是/dev目录下的文件）<br>5：查看配置文件的帮助<br>6：查看游戏的帮助<br>7：查看其它杂项的帮助<br>8：查看系统管理员可用命令的帮助<br>man -f 【命令】–可以查看这个命令有哪些级别</p><p>以下哪些方式/命令不可以查看某IP是否可达？top</p><p>在Linux系统中, 为找到文件try_grep含有以a字母为行开头的内容, 可以使用命令？grep -E ^a try_grep</p><p>^表示开头，$表示结束</p><p>grep:Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expr ession Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>-E  表示使用扩展表达式<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。</p><p>网络管理员在/opt分区上安装应用软件，提示磁盘可用空间不足,解决需要的指令和参数是（      ）<br>umount /opt  resize   parted</p><p>Windows平台通过栈溢（）出想要利用包含stack cookie保护的函数都有哪些可能的方式（）<br>暴力猜解cookie内容   更改函数内部变量改变逻辑  SEH覆盖</p><p>在linux网络编程中,以下关于socket描述符正确的是:<br>socket存在两种模式:阻塞和非阻塞<br>系统调用read从socket中读取数据时,当read返回0的时候,表示socket中数据读取完毕<br>如果socket设置成非阻塞模式,当socket的输入缓冲区没有可读数据时,read操作会返回错误<br>在阻塞socket上调用write函数发送数据,函数返回时,表示数据已经发送出去</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 我的第一篇个人博客<br>data: 2021-05-19</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于IPV4的流媒体广播系统</title>
      <link href="2021/05/29/%E5%9F%BA%E4%BA%8EIPV4%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E5%B9%BF%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/05/29/%E5%9F%BA%E4%BA%8EIPV4%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E5%B9%BF%E6%92%AD%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言小游戏之俄罗斯方块</title>
      <link href="2021/05/29/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%B9%8B%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
      <url>2021/05/29/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%B9%8B%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="如何用C语言实现俄罗斯方块"><a href="#如何用C语言实现俄罗斯方块" class="headerlink" title="如何用C语言实现俄罗斯方块"></a>如何用C语言实现俄罗斯方块</h1><h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><h2 id="输入设备的设置"><a href="#输入设备的设置" class="headerlink" title="输入设备的设置"></a>输入设备的设置</h2><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 Linux  Ubantu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言小游戏之贪吃蛇</title>
      <link href="2021/05/29/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>2021/05/29/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B8%B8%E6%88%8F%E4%B9%8B%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C语言学习</title>
      <link href="2021/05/21/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/05/21/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言学习"><a href="#嵌入式C语言学习" class="headerlink" title="嵌入式C语言学习"></a>嵌入式C语言学习</h1><p>大段函数用注释<br>#if 0</p><p>#endif</p><h2 id="数据类型，运算符和表达式"><a href="#数据类型，运算符和表达式" class="headerlink" title="数据类型，运算符和表达式"></a>数据类型，运算符和表达式</h2><ul><li>数据类型</li></ul><p>正数的补码就是他的2进制本身<br>负数的补码就是他的绝对值的2进制再取反加一</p><ul><li>常量与变量</li></ul><p>整形常量： 1，790，78，99</p><p>实形常量：9.8，2324.444，3.14</p><p>字符常量：由单引号引起来的单个的字符或转义字符</p><p>字符串常量：由双引号引起来的一个或多个字符组成的序列</p><p>标识常量：#define，处理在程序的预处理阶段，占编译时间，一改全改，但是不检查语法，只是单纯的宏体与宏名之间的替换</p><p>变量定义：</p><p>[存储类型]  数据类型  标识符 = 值<br>            type     name  = value;</p><p>标识符：由字母，数字，下划线组成且不能以数字开头的一个标识序列</p><p>数据类型：基本数据类型 + 构造类型</p><p>值：注意匹配</p><p>存储类型：auto static register(建议型) extern(说明型)</p><pre><code>auto  默认，自动分配空间，自动回收空间 如果没有指定存储类型的话就是默认autoregister 寄存器类型(寄存器存储在CPU中，运行速度快，数量较少，资源少速度快)，只能定义局部变量，不能定义全部变量；大小有限制，只能定义32位(32位系统)大小的数据类型；寄存器没有地址，所以一个寄存器类型的变量无法打印出地址查看或使用static：静态型，自动初始化为0值或空值，并且其变量的值由继承性。另外常用于修饰变量或者是函数extern：说明型，意味着不能改变被说明的变量的值或类型</code></pre><ul><li>变量的生命周期和作用范围</li></ul><p>全局变量和局部变量</p><p>全局变量：从当前定义位置开始直到当前程序结束(外部的作用范围)</p><p>全局变量副作用：</p><p>int i = 0 ;</p><p>void print_star(void)<br>{<br>    for()<br>        printf(“#”);<br>    printf(“\n”);</p><p>}</p><p>int main()<br>{<br>    for(i = 0;i &lt; 5 ; i ++)<br>    print_star();</p><pre><code>exit(0);</code></pre><p>}</p><p>局部变量：从当前定义位置开始直到当前函数结束(内部的作用范围)</p><p>内部作用范围屏蔽外部作用范围</p><p>局部变量和局部变量</p><p>仅作用于一段代码</p><p>参考图片：存储类型比较</p><ul><li>运算符和表达式</li></ul><p>加分号语句，不加分号表达式</p><p>运算符部分：</p><pre><code>每个运算符所需要的参与运算的操作数个数结合性优先级运算符的特殊用法：%：要求两边的数必须是整形= == ：等于表示负值，等等表示关系，逻辑运算符( &amp;&amp;  || )的短路特性++  --：运算符在前，先进行计算，再取变量值使用变量在前，先取变量值使用，在进行计算位运算的重要意义求字节数运算符：sizeof位运算的重要意义：&lt;&lt;：左移  右补零(乘以2)&gt;&gt;：右移  右去零(除以2)~：取反|：按位或^：异或&amp;：按位与将操作数中某一位置1，其他位不变  num = num | 1 &lt;&lt; n;将操作数中某一位置0，其他位不变num = num &amp;~ (1 &lt;&lt; n);测试第n位：if(num &amp; 1 &lt;&lt; n) 从一个指定宽度的数中取出其中某几位：#define GET_BIT_OF(v,n) (((v)&amp;(1&lt;&lt;(n)))?1:0)</code></pre><h2 id="输入，输出"><a href="#输入，输出" class="headerlink" title="输入，输出"></a>输入，输出</h2><ul><li>input output -&gt; I/O 操作 (标准IO  文件IO)</li></ul><p>1.格式化输入输出函数：scanf  printf</p><p>int printf(const char *format,…);</p><p>format:”% [修饰符] 格式字符”  参照图片标准输出修饰符与输入输出格式字符</p><p>int scanf(const char *format,…);</p><p>format:抑制符 *</p><p>%s的使用是比较危险的，因为不知道存储空间大小</p><p>sacnf放在循环结构中要注意能否接收到正常有效的内容</p><p>2.字符输入输出函数：getchar  putchar </p><p>3.字符串输入输出函数：gets(危险!)  puts  </p><p>gets：十分危险的函数，可以用fgets  getline来替代</p><ul><li>输入，输出部分联系</li></ul><p>一个水分子质量大约为3.0e-23g，一夸脱水大约有950g，编写以程序，要求终端输出水的夸脱数，然后显示这么多夸脱水中包含有大概多少水分子</p><p>从终端输入三角形的三边长，求面积  </p><p>从终端输入a,b,c的值求方程的根</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>用if else </p><p>成绩分级</p><p>平年闰年</p><p>用switch case</p><p>格式:<br>    switch()<br>    {<br>        case 常量或者常量表达式(程序的执行过程中不会发生变化的量):<br>            break;  跳出当前case</p><pre><code>    case 常量表达式:        break;    case 常量表达式:        break;    default:&#125; </code></pre><p>用switch case</p><p>成绩分级</p><p>选择，循环部分：</p><p>投资问题：A以每年10%的单利息投资了100美元，B以每年5%的复合利息投资了100美元。编写一程序，计算需要多少年B的投资总额才会超过A的，并且显示出到那一刻两人各自的资产总额</p><p>从终端读入数据，直到输入0为止，计算出其中偶数的个数及平均值和奇数的个数及平均值</p><p>从终端上输入若干字符，对其中的元音字母进行统计</p><p>写出fibonacci数列的前40项(不能用数组)</p><p>输出九九乘法表</p><p> 鸡翁一，值钱五；鸡母一，值钱三；三鸡雏，值钱一，百钱买百鸡，鸡翁，鸡母，鸡雏各几个？</p><p>求出1000以内的水仙花数：153 个位的立方＋十位的立方+百位的立方</p><p>求出1000以内的所有的质数</p><p>在终端上实现如下输出：<br>ABCDEF<br>BCDEF<br>CDEF<br>EF<br>F</p><p>输出下列形式：<br>*<br>**</p><hr><p>**<br>*</p><p>从终端输入N个数（以字母Q/q作为终止），求和</p><p>从半径为1开始输出圆的面积，直到面积大于100为止</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>构造类型之一，连续存放</p><ul><li>一维数组</li></ul><p>定义：【存储类型】  数据类型  标识符【下标】</p><p>初始化：</p><p>不初始化  分配一块空间，随机分配值</p><p>全部初始化  分配一块空间，对应分配值</p><p>部分初始化  分配一块空间，除了初始化的其它的值为0</p><p>static 值会被初始化为全0的状态</p><p>数组名是表示地址的常量，也是数组的起始位置</p><p>数组越界：数组越界不报错，只能人为检查，因为数组越界是由指针来完成的  a[i] = *(a+i)</p><p>练习题：</p><p>fibonacci数列前十项并在数组中逆序存放  </p><p>数据排列 冒泡 选择法 快速排序</p><p>冒泡法：N个数排序要进行N-1次排序才能实现</p><p>进制转换 </p><p>删除法求质数</p><ul><li>二维数组</li></ul><p>定义 初始化</p><p>【存储类型】 数据类型 标识符 【行下标】 【列下标】</p><p>二维数组在内存中的存储方式是以行为单位线性存储</p><p>元素引用</p><p>数组名 【行标】 【列标】</p><p>存储形式</p><p>顺序存储 按行存储 先行后列</p><p>深入理解二维数组</p><p>行指针</p><p>练习题：</p><p>行列互换</p><p>求最大值及其所在位置</p><p>求各行与各列的和</p><p>矩阵乘积</p><ul><li>字符数组</li></ul><p>常用函数：</p><p>strlen &amp; sizeof ：判断大小</p><p>strlen:不包含尾0</p><p>sizeof:包含尾0</p><p>strcpy &amp; strncpy ：给字符赋值</p><p>strcpy：容易有越界现象</p><p>strncpy：有大小可以控制，不容易越界</p><p>strcat &amp; strncat：连接字符</p><p>strcat：容易有越界现象</p><p>strncat：有大小可以控制，不容易越界</p><p>strcmp &amp; strncmp ：比较两个字符串的大小(实际比的是ascii)</p><p>相比一维二维数组多了尾0</p><p>练习：</p><p>给定一些文本，查看里面有多少单词</p><ul><li>多维数组</li></ul><h2 id="指针与变量"><a href="#指针与变量" class="headerlink" title="指针与变量"></a>指针与变量</h2><p>指针在某一平台下占据的大小的确认的</p><p>64：8   32：4</p><p>指针变量和他所指向的变量类型一定要一样</p><ul><li>变量与地址</li></ul><ul><li><p>指针与指针变量</p></li><li><p>直接访问与简介访问</p></li><li><p>空指针与野指针</p></li><li><p>空类型</p></li><li><p>定义与初始化的书写规则</p></li><li><p>指针运算</p></li><li><p>指针与数组</p></li></ul><p>指针与一维数组</p><p>a[i]:a[i] = *(a+i) = *(p+i) = p[i]</p><p>&amp;a[i]:&amp;a[i] = a+i  = p+i    = &amp;p[i]</p><p>指针与二维数组</p><p>指针与字符数组</p><ul><li>const与指针</li></ul><p>const:将某些内容常量化</p><p>const int a;</p><p>int const a;</p><p>const int *p;</p><p>int const *p;</p><p>int *const p;</p><p>const int *const p;</p><ul><li>指针数组 数组指针</li></ul><p>数组指针：是个指针，指向数组的指针</p><p>【存储类型】 数据类型 (*指针名)【下标】 = 值</p><p>int (*p)[3]</p><p>指针数组：是个每个元素都是指针的数组 </p><p>【存储类型】 数据类型 * 数组名【下标】</p><p>int * arr[3];</p><ul><li>多级指针</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>能够具体实现某个功能的小的代码</p><ul><li>函数的定义</li></ul><p>数据类型  函数名([数据类型  形参名])</p><ul><li>函数的传参</li></ul><p>值传递</p><p>地址传递</p><p>全局变量</p><ul><li>函数的调用</li></ul><p>嵌套调用</p><p>递归</p><p>一个数的阶乘是多少</p><p>int func(int n)<br>{<br>    if(n &lt; 0)<br>        return -1;</p><pre><code>if(n == 0 || n == 1)        return 1;return n * func(n-1); //遇到相同的函数调用会进行压栈保存</code></pre><p>}</p><p>int main()<br>{<br>    int n;<br>    int res;<br>    scanf(“%d”,&amp;n);</p><pre><code>res = func(n);printf(&quot;%d! = %d\n&quot;,n,res);return 0;</code></pre><p>}</p><p>fiboncci数列：</p><p>int fib(int n)<br>{<br>    if(n == 1 || n == 2)<br>        return 1;</p><pre><code>if(n &lt; 1)    return -1;return fib(n-2) + fib(n-1);</code></pre><p>}</p><p>int main()<br>{<br>    int n,res;</p><pre><code>scanf(&quot;%d&quot;,&amp;n);res = fib(n);printf(&quot;fib[%d] = %d\n&quot;,n,res);return 0;</code></pre><p>}</p><ul><li>函数与数组</li></ul><p>一维数组与函数</p><p>如何在一个函数中输出一维数组</p><p>将一数组逆序排列</p><p>void func(int *p,int n)<br>{<br>    int i = 0,j,m,tmp;</p><pre><code>m = (n-1)/2;for(; i&lt;=m ;i++)&#123;    j = n-1-i;    tmp = p[i]；    p[i] = p[j];    p[j] = tmp;&#125;</code></pre><p>}</p><p>int main()<br>{<br>    int i;<br>    int a[] = {1,2,3,4,5};<br>    func(a);<br>    return 0;<br>}</p><p>二维数组与函数</p><p>难的一批</p><ul><li>函数与指针</li></ul><p>指针函数</p><p>返回值 * 函数名(形参);</p><p>int * fun(int)</p><p>函数指针</p><p>类型(*指针名)(形参);</p><p>int (*p)(int);</p><p>函数指针数组</p><p>类型 (*数组名【下标】)(形参)</p><p>int (*p[10])(int)</p><p>指向指针函数的函数指针数组</p><h2 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h2><ul><li>结构体</li></ul><p>可以多种情况进行共存</p><p>微型学生管理系统</p><p>结构体的计算方式：</p><p>结构体成员的偏移量必须是成员大小的整数倍(0被认为是任何数的整数倍)</p><p>结构体大小必须是所有成员大小(数组，结构体除外)的整数倍</p><p>对齐方式浪费时间但是提升了效率</p><p>指定对齐值</p><p>（1）对齐值小于最大类型成员值</p><p>#pragma pack(4)  //指定向4对齐 最大是8</p><p>struct s6{<br>char ch;</p><p>int i;</p><p>float f;</p><p>double d;</p><p>};  得20</p><p>对齐值大于最大类型成员值</p><p>#pragma pack(10)</p><p>struct s7{<br>char ch;</p><p>int i;</p><p>float f;</p><p>double d;</p><p>};</p><p>我们指定的对齐值是10，最大为8，是否就向10对齐？不是，当指定对齐值大于自身对齐值时，向自身对其值对齐，大小是24.</p><p>总的来说，向指定对齐值和自身对齐值中较小的那个值对齐。</p><ul><li>共用体 </li></ul><p>结构体内的大小只按照最大的算</p><p>同时有多个情况存在，但是实际在某一时刻只有一种情况存在</p><ul><li>枚举</li></ul><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><ul><li>malloc ralloc realloc free</li></ul><p>原则：谁申请谁释放</p><ul><li>typedef</li></ul><p>针对某一个已有的类型来进行改名字的</p><p>typedef 已有的数据类型  新名字；</p><h2 id="Makefile-工程文件的编写规则"><a href="#Makefile-工程文件的编写规则" class="headerlink" title="Makefile 工程文件的编写规则"></a>Makefile 工程文件的编写规则</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>线性:</li></ul><p>线性表</p><p>栈</p><p>队列</p><ul><li>存储结构：</li></ul><p>顺序存储：数组</p><p>链式存储(有头还是无头)：链表 指针</p><p>链表：</p><p>单链表：</p><p>单项循环链表</p><p>单项不循环链表</p><p>双链表：</p><p>双项循环链表</p><p>双项不循环链</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式面试准备</title>
      <link href="2021/05/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>2021/05/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式面试题"><a href="#嵌入式面试题" class="headerlink" title="嵌入式面试题"></a>嵌入式面试题</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li> 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</li></ul><pre><code>  #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code></pre><ul><li>写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。<pre><code>#define MIN(A,B) ( (A) &lt;= (B) ? (A) : (B) )</code></pre></li></ul><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><ul><li><p>嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</p><p> while(1)<br> {</p><p> } </p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础速成NodeRed这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E9%80%9F%E6%88%90NodeRed%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E9%80%9F%E6%88%90NodeRed%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础学习stm32这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0stm32%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0stm32%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="stm32端口复用和重映射"><a href="#stm32端口复用和重映射" class="headerlink" title="stm32端口复用和重映射"></a>stm32端口复用和重映射</h1><h2 id="端口復用"><a href="#端口復用" class="headerlink" title="端口復用"></a>端口復用</h2><h2 id="端口重映射"><a href="#端口重映射" class="headerlink" title="端口重映射"></a>端口重映射</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础学习linux操作系统这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基础学习篇"><a href="#基础学习篇" class="headerlink" title="基础学习篇"></a>基础学习篇</h1><h2 id="linux命令入门演示"><a href="#linux命令入门演示" class="headerlink" title="linux命令入门演示"></a>linux命令入门演示</h2><ul><li><p>基本常用命令</p><p>  pwd      ：显示当前所在的目录</p><p>  ls       ：显示当前目录下的文件</p><p>  ls /home ：显示指定目录下的内容</p><p>  ls ~     ：指定显示家目录下的内容</p><p>  ls -l(long)：显示目录下文件的更详细信息(文件权限，文件最后修改时间，文件大小)</p><p>  ls -a(all)：显示了掩藏文件</p><p>  ls -h(human-able)：将文件大小以kb、mb、gb大小来表示</p><p>  cd       ：切换路径</p><p>  cd.      ：切换到当前路径</p><p>  cd..     ：返回到上一级路径</p><p>  cd../..  ：返回到上两级命令（在linux中路径分隔符为/）</p><p>  cd -     ：切换到上一次的路径</p><p>  mkdir    ：新建目录</p><p>  mkdir dir：创建dir这个文件</p><p>  mkdir -p 父目录/子目录</p><p>  mkdir -p dir1/dir2：连续创建多级目录，如果父目录不存在则需要加入-p参数</p><p>  rmdir ：删除目录</p><p>  rmdir 目录名 ：删除这个指定目录(不能删除非空目录)</p><p>  rm -r ：可以删除非空目录</p><p>  touch  文件名  ：新建文件(同一目录下无法创建同名目录)</p><p>  mv 旧名 新名：修改名(文件和目录都可以)</p><p>  mv 文件名 目录名：修改路径</p><p>  cp   源文件名 目标文件名    ：将当前目录下的文件拷贝成目标文件  cp file file1</p><p>  cp   源文件名  目标目录名  ：将当前目录下的文件拷贝到目标目录下  cp file dir/</p><p>  cp   -r  源目录名 目标目录名    ：将当前目录拷贝到目标目录  cp -r dir1 dir2  (-r为递归复制)</p><p>  cp -i file dir ：如果dir目录下面有同名的file文件，就会询问是否覆盖</p><p>  cat 文件     ：显示文件里面的内容</p><p>  cat 文件1 文件2     ：依次显示文件1和2里面的内容</p><p>  cat -n 文件  ：显示文件里面的内容和前面的行号</p><p>  rm  文件   ：删除文件</p><p>  rm -i 文件：终端会询问是否确认删除文件</p><p>  rm -r 文件：递归删除文件</p><p>  rm -ir 文件：每删除一个文件都会确认是否删除</p><p>  clear    ：清除屏幕显示内容(实际上刷新屏幕，会保留历史命令记录)</p><p>  reset   ：重新初始化屏幕，清除所有历史命令记录</p></li></ul><pre><code>echo $PATH    ：显示环境变量ctrl alt t    ：打开终端man  指令         ：调出对应指令的man手册info    ：和man差不多--help  ：和man差不多cd ~          ：返回到家目录（用户初始目录）vi * -p ：全部打开(通过gt在各个文件中相互切换)echo $?：查看上一步运行指令的返回值</code></pre><ul><li>shell是什么</li></ul><p>shell就是一个应用程序，我们可以通过键盘，串口给它发送命令，回车后他就会去执行这些命令</p><p>1.shell会解析字符串，这些字符串用空格分为好几个部分，第一部分就是程序名、命令名，其它部分是参数</p><p>2.shell会去PATH环境变量所指的位置找该程序</p><p>3.找到程序后，会启动该程序，并传入参数</p><ul><li>临时设置环境变量</li></ul><p>1.只对当前终端有效<br>export PATH=$PATH:/home/book</p><ul><li>永久修改环境变量</li></ul><p>1.修改~/.bashrc 在尾行添加或者修改：<br>export PATH=$PATH:/home/book</p><ul><li>命令提示符显示了</li></ul><p>1.当前登录的用户名</p><p>2.用户当前所在路径</p><ul><li>Linux命令的格式</li></ul><p>命令      [选项]     [参数]</p><p>ls     </p><p>ls -l  </p><p>ls -l /home</p><p>命令是一定存在的</p><p>选项和参数不一定存在</p><p>选项是以”-“来指明的</p><p>命令、选项、参数之间是以空格来隔开的</p><p>一个或多个空格都视为一个空格</p><ul><li>绝对路径和相对路径</li></ul><p>1.绝对路径：从根目录一级一级找下去，需要写完整的路径名 /xx/xx/xx</p><p>2.相对路径：参照当前所在目录进行查找 ./  ../</p><ul><li>vi编辑器有三种模式</li></ul><p>1.一般模式(光标移动、复制、粘贴、删除)</p><p>hjkl 可以移动光标，分别为左 下 上 右</p><p>ngg光移至第n行的行首(n为数字),如1gg就跳到第一行的行首</p><p>G转至文件结尾</p><p>0(数字零)光标移至当前行行首</p><p>$光标移至当前行行末</p><p>fx搜索当前行中下一个出现字母x的地方</p><p>文本复制：</p><p>yy复制当前行</p><p>nyy复制当前行和后面的n-1行(如5yy就是复制算上当前行的5行)</p><p>dd删除光标所在行</p><p>ndd删除当前行和后面的n-1行(如5yy就是复制算上当前行的5行)</p><p>使用p来粘贴</p><p>u 撤销</p><p>x 删除光标所在位置的字符 </p><p>/字符串 从光标开始处向文件尾部搜索字符串，后按下n或者N   n是在同一个方向上重复上一次搜索命令  N是在反方向重复上一次搜索命令</p><p>:%s/p1/p2/g将文件中所有的p1均用p2替换</p><p>:%s/p1/p2/gc替换时需要确认</p><p>find 查找符合条件的文件</p><p>格式：find  目录名 选项 查找条件</p><p>find /work/001_linux_basic/dira/ -name “test1.text” 说明： /work/001_linux_basic/dira/查找的路径  -name表明以名字来查找 “test1.text”查找的文件名</p><p>find /work/001_linux_basic/dira/ -name “dir” 说明： /work/001_linux_basic/dira/查找的路径  -name表明以名字来查找 “dir”查找的目录</p><p>如果没有指定目录即默认为当前目录</p><p>find . -name “*.text”  查找当前目录下的所有的text文件</p><p>find还有一些高级用法，可以查找最近几天(几个小时)之内有变动的文件  find /home -mtime -2 查找home目录下两天内有变动的文件</p><p>grep 查找文件中符合条件的字符串</p><p>格式：grep  选项 查找模式 文件名</p><p>grep -rn “字符串” 文件名</p><p>grep -rn “abc” text.text 在text.text中查找abc</p><p>可以加入-w全字匹配   grep -rnw “abc” text.text</p><p>grep -rn “abc” * 在当前目录递归查找abc</p><p>file ：识别文件类型</p><p>格式：file 文件名</p><p>linux 下一切皆文件</p><p>which和whereis ：查找命令或应用程序所在位置</p><p>格式：which  命令名/应用程序名</p><p>which pwd 定位到/bin/pwd</p><p>whereis pwd 查找到可执行程序的位置/bin/pwd和手册页的位置/usr/share/man/man1/pwd.1.gz</p><ul><li>压缩命令</li></ul><p>单个文件的压缩(解压)使用 gzip 和 bzip2</p><p>gzip的常用选项</p><p>-l 列出压缩文件的内容  gzip -l 压缩文件名</p><p>-k 在压缩或解压时，保留输入文件</p><p>-d 将压缩文件进行解压缩</p><p>解压：gzip -kd 压缩文件名</p><p>压缩：gzip -k  源文件名</p><p>相同的文件内容，如果文件名不同，压缩后的大小也不同</p><p>gzip只能压缩单个文件，不能压缩目录</p><p>多个文件和目录使用 tar</p><p>tar打包 gzip压缩</p><p>压缩：tar -czvf  压缩名      目录名</p><p>tar czvf        dira.tar.gz   dira</p><p>tar -czvf 与 tar czvf 相同</p><p>查看：tar tvf  压缩文件名</p><pre><code> tar tvf   dira.tar.gz</code></pre><p>解压：tar xzvf 压缩文件名</p><pre><code>  tar xzvf 压缩文件名 -C 指定目录</code></pre><p>tar打包 bizp2压缩</p><p>压缩：tar -cjvf  压缩名      目录名</p><p>tar cjvf        dira.tar.bz2   dira</p><p>tar -cjvf 与 tar cjvf 相同</p><p>查看：tar tvf  压缩文件名</p><pre><code> tar tvf   dira.tar.bz2</code></pre><p>解压：tar xjvf 压缩文件名</p><pre><code>  tar xjvf 压缩文件名 -C 指定目录  bzip2 和 gzip 相比，前者在大文件压缩时更有优势</code></pre><p>2.编辑模式(编辑文本)</p><p>i (在光标前开始插入文本)</p><p>o (在当前行之下新开一行，并到行首)</p><p>a (在光标后插入文本)</p><p>3.命令行模式(查找和替换)<br>/字符串 回车之后光标会自动移动到字符串的位置</p><h2 id="嵌入式linux应用开发基础知识"><a href="#嵌入式linux应用开发基础知识" class="headerlink" title="嵌入式linux应用开发基础知识"></a>嵌入式linux应用开发基础知识</h2><p>gcc -E main.c   查看预处理结果，比如头文件是哪</p><p>gcc -E -dM man.c &gt;1.text  把所有宏展开，存在1.text中</p><p>gcc -Wp,-MD,abc.dep -c -o main.o main.c  生成依赖文件abc.dep</p><ul><li>怎么编译多个文件</li></ul><p>1.一起编译，链接</p><p>gcc -o test main.c sub.c</p><p>2.分开编译，统一链接</p><p>gcc -c -o main.o main.c</p><p>gcc -c -o sub.o sub.c</p><p>gcc -o test main.o sub.o</p><ul><li>为什么要用Makefile</li></ul><p>修改源文件或头文件，只需要重新编译牵扯到的文件</p><ul><li>Makefile规则</li></ul><p>第一种:</p><p>test : main.c sub.c sub.h</p><pre><code>gcc -o test main.c sub.c</code></pre><p>第二种：</p><p>test : main.o sub.o </p><pre><code>gcc -o test main.o sub.o</code></pre><p>main.o : main.c </p><pre><code>gcc -c -o main.o main.c</code></pre><p>test : sub.c </p><pre><code>gcc -c -o sub.o sub.c</code></pre><p>clean:<br>    rm *.o test -f</p><p>第三种：<br>test : main.o sub.o </p><pre><code>gcc -o test main.o sub.o</code></pre><p>%.o : %.c<br>    gcc -c -o $@ $&lt;</p><p>sub.o : sub.h</p><p>clean:<br>    rm *.o test -f</p><p>终极Makefile:</p><p>objs := main.o sub.o</p><p>test : $(obj)</p><pre><code>gcc -o test $^</code></pre><p>#需要判断是否存在依赖文件</p><p>#.main.o.d .sub.o.d</p><p>dep_files := $(foreach f, $(objs), .$(f).d)</p><p>dep_files := $(wildcard $(dep_files))</p><p>#把依赖文件包含进来</p><p>ifneq ($(dep_files),)</p><pre><code>include $(dep_files)</code></pre><p>endif</p><p>%.o : %.c<br>    gcc -Wp,-MD, .$@.d -c -o $@ $&lt;</p><p>clean:<br>    rm *.o test -f</p><p>distclean<br>    rm $(dep_files) *.o test -f</p><ul><li>有个通用的超级无敌好用的Makefile,上B站找韦东山，工作中也许会用到</li></ul><h2 id="嵌入式linux驱动开发基础知识"><a href="#嵌入式linux驱动开发基础知识" class="headerlink" title="嵌入式linux驱动开发基础知识"></a>嵌入式linux驱动开发基础知识</h2><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇个人博客</title>
      <link href="2021/05/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/05/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="需要的编辑软件"><a href="#需要的编辑软件" class="headerlink" title="需要的编辑软件"></a>需要的编辑软件</h2><ul><li>vscode<br>个人建议在国内的网站上面下载，官网上面太慢了</li><li>Typora</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1483731740,4186543320&fm=26&gp=0.jpg"> </p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/s?ie=UTF-8&wd=%E6%B1%9F%E5%B1%B1%E9%94%99%E8%90%BD%20%E4%BA%BA%E9%97%B4%E6%98%9F%E7%81%AB">123</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/18/hello-world/"/>
      <url>2021/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
