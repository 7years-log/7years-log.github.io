<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>嵌入式C语言学习</title>
      <link href="2021/05/21/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/05/21/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言学习"><a href="#嵌入式C语言学习" class="headerlink" title="嵌入式C语言学习"></a>嵌入式C语言学习</h1><p>大段函数用注释<br>#if 0</p><p>#endif</p><h2 id="数据类型，运算符和表达式"><a href="#数据类型，运算符和表达式" class="headerlink" title="数据类型，运算符和表达式"></a>数据类型，运算符和表达式</h2><ul><li>数据类型</li></ul><p>正数的补码就是他的2进制本身<br>负数的补码就是他的绝对值的2进制再取反加一</p><ul><li>常量与变量</li></ul><p>整形常量： 1，790，78，99</p><p>实形常量：9.8，2324.444，3.14</p><p>字符常量：由单引号引起来的单个的字符或转义字符</p><p>字符串常量：由双引号引起来的一个或多个字符组成的序列</p><p>标识常量：#define，处理在程序的预处理阶段，占编译时间，一改全改，但是不检查语法，只是单纯的宏体与宏名之间的替换</p><p>变量定义：</p><p>[存储类型]  数据类型  标识符 = 值<br>            type     name  = value;</p><p>标识符：由字母，数字，下划线组成且不能以数字开头的一个标识序列</p><p>数据类型：基本数据类型 + 构造类型</p><p>值：注意匹配</p><p>存储类型：auto static register(建议型) extern(说明型)</p><pre><code>auto  默认，自动分配空间，自动回收空间 如果没有指定存储类型的话就是默认autoregister 寄存器类型(寄存器存储在CPU中，运行速度快，数量较少，资源少速度快)，只能定义局部变量，不能定义全部变量；大小有限制，只能定义32位(32位系统)大小的数据类型；寄存器没有地址，所以一个寄存器类型的变量无法打印出地址查看或使用static：静态型，自动初始化为0值或空值，并且其变量的值由继承性。另外常用于修饰变量或者是函数extern：说明型，意味着不能改变被说明的变量的值或类型</code></pre><ul><li>变量的生命周期和作用范围</li></ul><p>全局变量和局部变量</p><p>全局变量：从当前定义位置开始直到当前程序结束(外部的作用范围)</p><p>全局变量副作用：</p><p>int i = 0 ;</p><p>void print_star(void)<br>{<br>    for()<br>        printf(“#”);<br>    printf(“\n”);</p><p>}</p><p>int main()<br>{<br>    for(i = 0;i &lt; 5 ; i ++)<br>    print_star();</p><pre><code>exit(0);</code></pre><p>}</p><p>局部变量：从当前定义位置开始直到当前函数结束(内部的作用范围)</p><p>内部作用范围屏蔽外部作用范围</p><p>局部变量和局部变量</p><p>仅作用于一段代码</p><p>参考图片：存储类型比较</p><ul><li>运算符和表达式</li></ul><p>加分号语句，不加分号表达式</p><p>运算符部分：</p><pre><code>每个运算符所需要的参与运算的操作数个数结合性优先级运算符的特殊用法：%：要求两边的数必须是整形= == ：等于表示负值，等等表示关系，逻辑运算符( &amp;&amp;  || )的短路特性++  --：运算符在前，先进行计算，再取变量值使用变量在前，先取变量值使用，在进行计算位运算的重要意义求字节数运算符：sizeof位运算的重要意义：&lt;&lt;：左移  右补零(乘以2)&gt;&gt;：右移  右去零(除以2)~：取反|：按位或^：异或&amp;：按位与将操作数中某一位置1，其他位不变  num = num | 1 &lt;&lt; n;将操作数中某一位置0，其他位不变num = num &amp;~ (1 &lt;&lt; n);测试第n位：if(num &amp; 1 &lt;&lt; n) 从一个指定宽度的数中取出其中某几位：#define GET_BIT_OF(v,n) (((v)&amp;(1&lt;&lt;(n)))?1:0)</code></pre><h2 id="输入，输出"><a href="#输入，输出" class="headerlink" title="输入，输出"></a>输入，输出</h2><ul><li>input output -&gt; I/O 操作 (标准IO  文件IO)</li></ul><p>1.格式化输入输出函数：scanf  printf</p><p>int printf(const char *format,…);</p><p>format:”% [修饰符] 格式字符”  参照图片标准输出修饰符与输入输出格式字符</p><p>int scanf(const char *format,…);</p><p>format:抑制符 *</p><p>%s的使用是比较危险的，因为不知道存储空间大小</p><p>sacnf放在循环结构中要注意能否接收到正常有效的内容</p><p>2.字符输入输出函数：getchar  putchar </p><p>3.字符串输入输出函数：gets(危险!)  puts  </p><p>gets：十分危险的函数，可以用fgets  getline来替代</p><ul><li>输入，输出部分联系</li></ul><p>一个水分子质量大约为3.0e-23g，一夸脱水大约有950g，编写以程序，要求终端输出水的夸脱数，然后显示这么多夸脱水中包含有大概多少水分子</p><p>从终端输入三角形的三边长，求面积  </p><p>从终端输入a,b,c的值求方程的根</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>用if else </p><p>成绩分级</p><p>平年闰年</p><p>用switch case</p><p>格式:<br>    switch()<br>    {<br>        case 常量或者常量表达式(程序的执行过程中不会发生变化的量):<br>            break;  跳出当前case</p><pre><code>    case 常量表达式:        break;    case 常量表达式:        break;    default:&#125; </code></pre><p>用switch case</p><p>成绩分级</p><p>选择，循环部分：</p><p>投资问题：A以每年10%的单利息投资了100美元，B以每年5%的复合利息投资了100美元。编写一程序，计算需要多少年B的投资总额才会超过A的，并且显示出到那一刻两人各自的资产总额</p><p>从终端读入数据，直到输入0为止，计算出其中偶数的个数及平均值和奇数的个数及平均值</p><p>从终端上输入若干字符，对其中的元音字母进行统计</p><p>写出fibonacci数列的前40项(不能用数组)</p><p>输出九九乘法表</p><p> 鸡翁一，值钱五；鸡母一，值钱三；三鸡雏，值钱一，百钱买百鸡，鸡翁，鸡母，鸡雏各几个？</p><p>求出1000以内的水仙花数：153 个位的立方＋十位的立方+百位的立方</p><p>求出1000以内的所有的质数</p><p>在终端上实现如下输出：<br>ABCDEF<br>BCDEF<br>CDEF<br>EF<br>F</p><p>输出下列形式：<br>*<br>**</p><hr><p>**<br>*</p><p>从终端输入N个数（以字母Q/q作为终止），求和</p><p>从半径为1开始输出圆的面积，直到面积大于100为止</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>构造类型之一，连续存放</p><ul><li>一维数组</li></ul><p>定义：【存储类型】  数据类型  标识符【下标】</p><p>初始化：</p><p>不初始化  分配一块空间，随机分配值</p><p>全部初始化  分配一块空间，对应分配值</p><p>部分初始化  分配一块空间，除了初始化的其它的值为0</p><p>static 值会被初始化为全0的状态</p><p>数组名是表示地址的常量，也是数组的起始位置</p><p>数组越界：数组越界不报错，只能人为检查，因为数组越界是由指针来完成的  a[i] = *(a+i)</p><p>练习题：</p><p>fibonacci数列前十项并在数组中逆序存放  </p><p>数据排列 冒泡 选择法 快速排序</p><p>冒泡法：N个数排序要进行N-1次排序才能实现</p><p>进制转换 </p><p>删除法求质数</p><ul><li>二维数组</li></ul><p>定义 初始化</p><p>【存储类型】 数据类型 标识符 【行下标】 【列下标】</p><p>二维数组在内存中的存储方式是以行为单位线性存储</p><p>元素引用</p><p>数组名 【行标】 【列标】</p><p>存储形式</p><p>顺序存储 按行存储 先行后列</p><p>深入理解二维数组</p><p>行指针</p><p>练习题：</p><p>行列互换</p><p>求最大值及其所在位置</p><p>求各行与各列的和</p><p>矩阵乘积</p><ul><li>字符数组</li></ul><p>常用函数：</p><p>strlen &amp; sizeof ：判断大小</p><p>strlen:不包含尾0</p><p>sizeof:包含尾0</p><p>strcpy &amp; strncpy ：给字符赋值</p><p>strcpy：容易有越界现象</p><p>strncpy：有大小可以控制，不容易越界</p><p>strcat &amp; strncat：连接字符</p><p>strcat：容易有越界现象</p><p>strncat：有大小可以控制，不容易越界</p><p>strcmp &amp; strncmp ：比较两个字符串的大小(实际比的是ascii)</p><p>相比一维二维数组多了尾0</p><p>练习：</p><p>给定一些文本，查看里面有多少单词</p><ul><li>多维数组</li></ul><h2 id="指针与变量"><a href="#指针与变量" class="headerlink" title="指针与变量"></a>指针与变量</h2><p>指针在某一平台下占据的大小的确认的</p><p>64：8   32：4</p><p>指针变量和他所指向的变量类型一定要一样</p><ul><li>变量与地址</li></ul><ul><li><p>指针与指针变量</p></li><li><p>直接访问与简介访问</p></li><li><p>空指针与野指针</p></li><li><p>空类型</p></li><li><p>定义与初始化的书写规则</p></li><li><p>指针运算</p></li><li><p>指针与数组</p></li></ul><p>指针与一维数组</p><p>a[i]:a[i] = *(a+i) = *(p+i) = p[i]</p><p>&amp;a[i]:&amp;a[i] = a+i  = p+i    = &amp;p[i]</p><p>指针与二维数组</p><p>指针与字符数组</p><ul><li>const与指针</li></ul><p>const:将某些内容常量化</p><p>const int a;</p><p>int const a;</p><p>const int *p;</p><p>int const *p;</p><p>int *const p;</p><p>const int *const p;</p><ul><li>指针数组 数组指针</li></ul><p>数组指针：是个指针，指向数组的指针</p><p>【存储类型】 数据类型 (*指针名)【下标】 = 值</p><p>int (*p)[3]</p><p>指针数组：是个每个元素都是指针的数组 </p><p>【存储类型】 数据类型 * 数组名【下标】</p><p>int * arr[3];</p><ul><li>多级指针</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>能够具体实现某个功能的小的代码</p><ul><li>函数的定义</li></ul><p>数据类型  函数名([数据类型  形参名])</p><ul><li>函数的传参</li></ul><p>值传递</p><p>地址传递</p><p>全局变量</p><ul><li>函数的调用</li></ul><p>嵌套调用</p><p>递归</p><p>一个数的阶乘是多少</p><p>int func(int n)<br>{<br>    if(n &lt; 0)<br>        return -1;</p><pre><code>if(n == 0 || n == 1)        return 1;return n * func(n-1); //遇到相同的函数调用会进行压栈保存</code></pre><p>}</p><p>int main()<br>{<br>    int n;<br>    int res;<br>    scanf(“%d”,&amp;n);</p><pre><code>res = func(n);printf(&quot;%d! = %d\n&quot;,n,res);return 0;</code></pre><p>}</p><p>fiboncci数列：</p><p>int fib(int n)<br>{<br>    if(n == 1 || n == 2)<br>        return 1;</p><pre><code>if(n &lt; 1)    return -1;return fib(n-2) + fib(n-1);</code></pre><p>}</p><p>int main()<br>{<br>    int n,res;</p><pre><code>scanf(&quot;%d&quot;,&amp;n);res = fib(n);printf(&quot;fib[%d] = %d\n&quot;,n,res);return 0;</code></pre><p>}</p><ul><li>函数与数组</li></ul><p>一维数组与函数</p><p>如何在一个函数中输出一维数组</p><p>将一数组逆序排列</p><p>void func(int *p,int n)<br>{<br>    int i = 0,j,m,tmp;</p><pre><code>m = (n-1)/2;for(; i&lt;=m ;i++)&#123;    j = n-1-i;    tmp = p[i]；    p[i] = p[j];    p[j] = tmp;&#125;</code></pre><p>}</p><p>int main()<br>{<br>    int i;<br>    int a[] = {1,2,3,4,5};<br>    func(a);<br>    return 0;<br>}</p><p>二维数组与函数</p><p>难的一批</p><ul><li>函数与指针</li></ul><p>指针函数</p><p>返回值 * 函数名(形参);</p><p>int * fun(int)</p><p>函数指针</p><p>类型(*指针名)(形参);</p><p>int (*p)(int);</p><p>函数指针数组</p><p>类型 (*数组名【下标】)(形参)</p><p>int (*p[10])(int)</p><p>指向指针函数的函数指针数组</p><h2 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h2><ul><li>结构体</li></ul><p>可以多种情况进行共存</p><p>微型学生管理系统</p><ul><li>共用体 </li></ul><p>同时有多个情况存在，但是实际在某一时刻只有一种情况存在</p><ul><li>枚举</li></ul><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><ul><li>malloc ralloc realloc free</li></ul><p>原则：谁申请谁释放</p><ul><li>typedef</li></ul><p>针对某一个已有的类型来进行改名字的</p><p>typedef 已有的数据类型  新名字；</p><h2 id="Makefile-工程文件的编写规则"><a href="#Makefile-工程文件的编写规则" class="headerlink" title="Makefile 工程文件的编写规则"></a>Makefile 工程文件的编写规则</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>线性:</li></ul><p>线性表</p><p>栈</p><p>队列</p><ul><li>存储结构：</li></ul><p>顺序存储：数组</p><p>链式存储(有头还是无头)：链表 指针</p><p>链表：</p><p>单链表：</p><p>单项循环链表</p><p>单项不循环链表</p><p>双链表：</p><p>双项循环链表</p><p>双项不循环链</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式面试准备</title>
      <link href="2021/05/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
      <url>2021/05/20/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式面试题"><a href="#嵌入式面试题" class="headerlink" title="嵌入式面试题"></a>嵌入式面试题</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><ul><li> 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）</li></ul><pre><code>  #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code></pre><ul><li>写一个”标准”宏MIN ，这个宏输入两个参数并返回较小的一个。<pre><code>#define MIN(A,B) ( (A) &lt;= (B) ? (A) : (B) )</code></pre></li></ul><h2 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h2><ul><li><p>嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</p><p> while(1)<br> {</p><p> } </p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础速成NodeRed这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E9%80%9F%E6%88%90NodeRed%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E9%80%9F%E6%88%90NodeRed%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础学习stm32这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0stm32%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0stm32%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我0基础学习linux操作系统这件事 一</title>
      <link href="2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/"/>
      <url>2021/05/19/%E5%85%B3%E4%BA%8E%E6%88%910%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%99%E4%BB%B6%E4%BA%8B-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基础学习篇"><a href="#基础学习篇" class="headerlink" title="基础学习篇"></a>基础学习篇</h1><h2 id="linux命令入门演示"><a href="#linux命令入门演示" class="headerlink" title="linux命令入门演示"></a>linux命令入门演示</h2><ul><li><p>基本常用命令</p><p>  pwd      ：显示当前所在的目录</p><p>  ls       ：显示当前目录下的文件</p><p>  ls /home ：显示指定目录下的内容</p><p>  ls ~     ：指定显示家目录下的内容</p><p>  ls -l(long)：显示目录下文件的更详细信息(文件权限，文件最后修改时间，文件大小)</p><p>  ls -a(all)：显示了掩藏文件</p><p>  ls -h(human-able)：将文件大小以kb、mb、gb大小来表示</p><p>  cd       ：切换路径</p><p>  cd.      ：切换到当前路径</p><p>  cd..     ：返回到上一级路径</p><p>  cd../..  ：返回到上两级命令（在linux中路径分隔符为/）</p><p>  cd -     ：切换到上一次的路径</p><p>  mkdir    ：新建目录</p><p>  mkdir dir：创建dir这个文件</p><p>  mkdir -p 父目录/子目录</p><p>  mkdir -p dir1/dir2：连续创建多级目录，如果父目录不存在则需要加入-p参数</p><p>  rmdir ：删除目录</p><p>  rmdir 目录名 ：删除这个指定目录(不能删除非空目录)</p><p>  rm -r ：可以删除非空目录</p><p>  touch  文件名  ：新建文件(同一目录下无法创建同名目录)</p><p>  mv 旧名 新名：修改名(文件和目录都可以)</p><p>  mv 文件名 目录名：修改路径</p><p>  cp   源文件名 目标文件名    ：将当前目录下的文件拷贝成目标文件  cp file file1</p><p>  cp   源文件名  目标目录名  ：将当前目录下的文件拷贝到目标目录下  cp file dir/</p><p>  cp   -r  源目录名 目标目录名    ：将当前目录拷贝到目标目录  cp -r dir1 dir2  (-r为递归复制)</p><p>  cp -i file dir ：如果dir目录下面有同名的file文件，就会询问是否覆盖</p><p>  cat 文件     ：显示文件里面的内容</p><p>  cat 文件1 文件2     ：依次显示文件1和2里面的内容</p><p>  cat -n 文件  ：显示文件里面的内容和前面的行号</p><p>  rm  文件   ：删除文件</p><p>  rm -i 文件：终端会询问是否确认删除文件</p><p>  rm -r 文件：递归删除文件</p><p>  rm -ir 文件：每删除一个文件都会确认是否删除</p><p>  clear    ：清除屏幕显示内容(实际上刷新屏幕，会保留历史命令记录)</p><p>  reset   ：重新初始化屏幕，清除所有历史命令记录</p></li></ul><pre><code>echo $PATH    ：显示环境变量ctrl alt t    ：打开终端man  指令         ：调出对应指令的man手册info    ：和man差不多--help  ：和man差不多cd ~          ：返回到家目录（用户初始目录）vi * -p ：全部打开(通过gt在各个文件中相互切换)echo $?：查看上一步运行指令的返回值</code></pre><ul><li>shell是什么</li></ul><p>shell就是一个应用程序，我们可以通过键盘，串口给它发送命令，回车后他就会去执行这些命令</p><p>1.shell会解析字符串，这些字符串用空格分为好几个部分，第一部分就是程序名、命令名，其它部分是参数</p><p>2.shell会去PATH环境变量所指的位置找该程序</p><p>3.找到程序后，会启动该程序，并传入参数</p><ul><li>临时设置环境变量</li></ul><p>1.只对当前终端有效<br>export PATH=$PATH:/home/book</p><ul><li>永久修改环境变量</li></ul><p>1.修改~/.bashrc 在尾行添加或者修改：<br>export PATH=$PATH:/home/book</p><ul><li>命令提示符显示了</li></ul><p>1.当前登录的用户名</p><p>2.用户当前所在路径</p><ul><li>Linux命令的格式</li></ul><p>命令      [选项]     [参数]</p><p>ls     </p><p>ls -l  </p><p>ls -l /home</p><p>命令是一定存在的</p><p>选项和参数不一定存在</p><p>选项是以”-“来指明的</p><p>命令、选项、参数之间是以空格来隔开的</p><p>一个或多个空格都视为一个空格</p><ul><li>绝对路径和相对路径</li></ul><p>1.绝对路径：从根目录一级一级找下去，需要写完整的路径名 /xx/xx/xx</p><p>2.相对路径：参照当前所在目录进行查找 ./  ../</p><ul><li>vi编辑器有三种模式</li></ul><p>1.一般模式(光标移动、复制、粘贴、删除)</p><p>hjkl 可以移动光标，分别为左 下 上 右</p><p>ngg光移至第n行的行首(n为数字),如1gg就跳到第一行的行首</p><p>G转至文件结尾</p><p>0(数字零)光标移至当前行行首</p><p>$光标移至当前行行末</p><p>fx搜索当前行中下一个出现字母x的地方</p><p>文本复制：</p><p>yy复制当前行</p><p>nyy复制当前行和后面的n-1行(如5yy就是复制算上当前行的5行)</p><p>dd删除光标所在行</p><p>ndd删除当前行和后面的n-1行(如5yy就是复制算上当前行的5行)</p><p>使用p来粘贴</p><p>u 撤销</p><p>x 删除光标所在位置的字符 </p><p>/字符串 从光标开始处向文件尾部搜索字符串，后按下n或者N   n是在同一个方向上重复上一次搜索命令  N是在反方向重复上一次搜索命令</p><p>:%s/p1/p2/g将文件中所有的p1均用p2替换</p><p>:%s/p1/p2/gc替换时需要确认</p><p>find 查找符合条件的文件</p><p>格式：find  目录名 选项 查找条件</p><p>find /work/001_linux_basic/dira/ -name “test1.text” 说明： /work/001_linux_basic/dira/查找的路径  -name表明以名字来查找 “test1.text”查找的文件名</p><p>find /work/001_linux_basic/dira/ -name “dir” 说明： /work/001_linux_basic/dira/查找的路径  -name表明以名字来查找 “dir”查找的目录</p><p>如果没有指定目录即默认为当前目录</p><p>find . -name “*.text”  查找当前目录下的所有的text文件</p><p>find还有一些高级用法，可以查找最近几天(几个小时)之内有变动的文件  find /home -mtime -2 查找home目录下两天内有变动的文件</p><p>grep 查找文件中符合条件的字符串</p><p>格式：grep  选项 查找模式 文件名</p><p>grep -rn “字符串” 文件名</p><p>grep -rn “abc” text.text 在text.text中查找abc</p><p>可以加入-w全字匹配   grep -rnw “abc” text.text</p><p>grep -rn “abc” * 在当前目录递归查找abc</p><p>file ：识别文件类型</p><p>格式：file 文件名</p><p>linux 下一切皆文件</p><p>which和whereis ：查找命令或应用程序所在位置</p><p>格式：which  命令名/应用程序名</p><p>which pwd 定位到/bin/pwd</p><p>whereis pwd 查找到可执行程序的位置/bin/pwd和手册页的位置/usr/share/man/man1/pwd.1.gz</p><ul><li>压缩命令</li></ul><p>单个文件的压缩(解压)使用 gzip 和 bzip2</p><p>gzip的常用选项</p><p>-l 列出压缩文件的内容  gzip -l 压缩文件名</p><p>-k 在压缩或解压时，保留输入文件</p><p>-d 将压缩文件进行解压缩</p><p>解压：gzip -kd 压缩文件名</p><p>压缩：gzip -k  源文件名</p><p>相同的文件内容，如果文件名不同，压缩后的大小也不同</p><p>gzip只能压缩单个文件，不能压缩目录</p><p>多个文件和目录使用 tar</p><p>tar打包 gzip压缩</p><p>压缩：tar -czvf  压缩名      目录名</p><p>tar czvf        dira.tar.gz   dira</p><p>tar -czvf 与 tar czvf 相同</p><p>查看：tar tvf  压缩文件名</p><pre><code> tar tvf   dira.tar.gz</code></pre><p>解压：tar xzvf 压缩文件名</p><pre><code>  tar xzvf 压缩文件名 -C 指定目录</code></pre><p>tar打包 bizp2压缩</p><p>压缩：tar -cjvf  压缩名      目录名</p><p>tar cjvf        dira.tar.bz2   dira</p><p>tar -cjvf 与 tar cjvf 相同</p><p>查看：tar tvf  压缩文件名</p><pre><code> tar tvf   dira.tar.bz2</code></pre><p>解压：tar xjvf 压缩文件名</p><pre><code>  tar xjvf 压缩文件名 -C 指定目录  bzip2 和 gzip 相比，前者在大文件压缩时更有优势</code></pre><p>2.编辑模式(编辑文本)</p><p>i (在光标前开始插入文本)</p><p>o (在当前行之下新开一行，并到行首)</p><p>a (在光标后插入文本)</p><p>3.命令行模式(查找和替换)<br>/字符串 回车之后光标会自动移动到字符串的位置</p><h2 id="嵌入式linux应用开发基础知识"><a href="#嵌入式linux应用开发基础知识" class="headerlink" title="嵌入式linux应用开发基础知识"></a>嵌入式linux应用开发基础知识</h2><p>gcc -E main.c   查看预处理结果，比如头文件是哪</p><p>gcc -E -dM man.c &gt;1.text  把所有宏展开，存在1.text中</p><p>gcc -Wp,-MD,abc.dep -c -o main.o main.c  生成依赖文件abc.dep</p><ul><li>怎么编译多个文件</li></ul><p>1.一起编译，链接</p><p>gcc -o test main.c sub.c</p><p>2.分开编译，统一链接</p><p>gcc -c -o main.o main.c</p><p>gcc -c -o sub.o sub.c</p><p>gcc -o test main.o sub.o</p><ul><li>为什么要用Makefile</li></ul><p>修改源文件或头文件，只需要重新编译牵扯到的文件</p><ul><li>Makefile规则</li></ul><p>第一种:</p><p>test : main.c sub.c sub.h</p><pre><code>gcc -o test main.c sub.c</code></pre><p>第二种：</p><p>test : main.o sub.o </p><pre><code>gcc -o test main.o sub.o</code></pre><p>main.o : main.c </p><pre><code>gcc -c -o main.o main.c</code></pre><p>test : sub.c </p><pre><code>gcc -c -o sub.o sub.c</code></pre><p>clean:<br>    rm *.o test -f</p><p>第三种：<br>test : main.o sub.o </p><pre><code>gcc -o test main.o sub.o</code></pre><p>%.o : %.c<br>    gcc -c -o $@ $&lt;</p><p>sub.o : sub.h</p><p>clean:<br>    rm *.o test -f</p><p>终极Makefile:</p><p>objs := main.o sub.o</p><p>test : $(obj)</p><pre><code>gcc -o test $^</code></pre><p>#需要判断是否存在依赖文件</p><p>#.main.o.d .sub.o.d</p><p>dep_files := $(foreach f, $(objs), .$(f).d)</p><p>dep_files := $(wildcard $(dep_files))</p><p>#把依赖文件包含进来</p><p>ifneq ($(dep_files),)</p><pre><code>include $(dep_files)</code></pre><p>endif</p><p>%.o : %.c<br>    gcc -Wp,-MD, .$@.d -c -o $@ $&lt;</p><p>clean:<br>    rm *.o test -f</p><p>distclean<br>    rm $(dep_files) *.o test -f</p><ul><li>有个通用的超级无敌好用的Makefile,上B站找韦东山，工作中也许会用到</li></ul><h2 id="嵌入式linux驱动开发基础知识"><a href="#嵌入式linux驱动开发基础知识" class="headerlink" title="嵌入式linux驱动开发基础知识"></a>嵌入式linux驱动开发基础知识</h2><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇个人博客</title>
      <link href="2021/05/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2021/05/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="需要的编辑软件"><a href="#需要的编辑软件" class="headerlink" title="需要的编辑软件"></a>需要的编辑软件</h2><ul><li>vscode<br>个人建议在国内的网站上面下载，官网上面太慢了</li><li>Typora</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1483731740,4186543320&fm=26&gp=0.jpg"> </p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://www.baidu.com/s?ie=UTF-8&wd=%E6%B1%9F%E5%B1%B1%E9%94%99%E8%90%BD%20%E4%BA%BA%E9%97%B4%E6%98%9F%E7%81%AB">123</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/18/hello-world/"/>
      <url>2021/05/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
